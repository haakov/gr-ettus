# auto-generated by grc.converter

id: uhd_rfnoc_streamer_fft
label: 'RFNoC: FFT'

parameters:
-   id: fft_size
    label: FFT Size
    dtype: int
    default: '64'
    options: ['8', '16', '32', '64', '128', '256', '512', '1024']
    hide: ${ 'part' if vlen == 1 else 'none' }
-   id: direction
    label: Forward/Reverse
    dtype: enum
    options: ['"forward"', '"reverse"']
    option_labels: [Forward, Reverse]
-   id: shift
    label: Shift
    dtype: enum
    options: ['"normal"', '"natural"', '"reverse"']
    option_labels: ['Yes', 'No', Reversed]
-   id: magnitude_out
    label: FFT Output
    dtype: enum
    options: ['"COMPLEX"', '"MAGNITUDE"', '"MAGNITUDE_SQUARED"']
    option_labels: [Complex, Magnitude, Magnitude^2]
-   id: scaling
    label: FFT Scaling Word
    dtype: int
    default: '1706'
-   id: block_index
    label: Block Select
    category: RFNoC Config
    dtype: int
    default: '-1'
    hide: ${ ('part' if int(block_index) < 0 else 'none') }
-   id: device_index
    label: Device Select
    category: RFNoC Config
    dtype: int
    default: '-1'
    hide: ${ ('part' if int(device_index) < 0 else 'none') }
-   id: fpga_module_name
    label: FPGA Module Name
    category: RFNoC Config
    dtype: string
    default: noc_block_fft
    hide: all

inputs:
-   domain: stream
    dtype: complex
    vlen: ${ fft_size }

outputs:
-   domain: stream
    dtype: complex
    vlen: ${ fft_size }
asserts:
- ${ fft_size in [2**n for n in xrange(3, 11)] }

templates:
    imports: import ettus
    make: "ettus.rfnoc_generic(\n    self.device3,\n    uhd.stream_args( \\# TX Stream\
        \ Args\n        cpu_format=\"fc32\", \\# TODO: This must be made an option\n\
        \        otw_format=\"sc16\",\n        args=\"\",\n    ),\n    uhd.stream_args(\
        \ \\# RX Stream Args\n        cpu_format=\"fc32\", \\# TODO: This must be\
        \ made an option\n        otw_format=\"sc16\",\n        args=\"\",\n    ),\n\
        \    \"FFT\", ${block_index}, ${device_index},\n)\nself.${id}.set_arg(\"spp\"\
        , ${fft_size})\nself.${id}.set_arg(\"direction\", ${direction})\nself.${id}.set_arg(\"\
        scaling\", ${scaling})\nself.${id}.set_arg(\"shift\", ${shift})\nself.${id}.set_arg(\"\
        magnitude_out\", ${magnitude_out})\n  "
    callbacks:
    - set_arg("spp", ${fft_size})
    - set_arg("direction", ${direction})
    - set_arg("scaling", ${scaling})
    - set_arg("shift", ${shift})
    - set_arg("magnitude_out", ${magnitude_out})

documentation: |-
    On the X3x0 the FFT block currently requires that the Ethernet MTU size be set to 8*FFT size as the FFT result must fit inside a single packet.

file_format: 1
